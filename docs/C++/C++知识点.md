
# C和C++的区别？

C++在C的基础上增添类

C是一个结构化语言，它的重点在于算法和数据结构。

C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。

# C++程序执行过程

1. 预处理（产生.i文件，-E）
2. 编译（产生.s文件，-s）
3. 汇编（产生.o或.obj文件，-c）
4. 链接（产生.out或.exe文件，-o）

# [动态链接库与静态链接库的区别](https://blog.csdn.net/fuzhongmin05/article/details/54616520)

静态链接:是指把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。换句话说，函数和过程的代码就在程序的exe文件中，该文件包含了运行时所需的全部代码。当多个程序都调用相同函数时，内存中就会存在这个函数的多个拷贝，这样就浪费了宝贵的内存资源。

动态链接是相对静态链接而言的:动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息）。仅当应用程序被装入内存开始运行时，在Windows的管理下，才在应用程序与相应的DLL之间建立链接关系。当要执行所调用DLL中的函数时，根据链接产生的重定位信息，Windows才转去执行DLL中相应的函数代码。一般情况下，如果一个应用程序使用了动态链接库，Win32系统保证内存中只有DLL的一份复制品。

静态链接的可执行文件能够在其他同类操作系统上直接运行。例如，一个exe文件是在Windows 2000系统上静态链接的，那么将该文件直接拷贝到另一台Windows 2000的机器上，是可以运行的。而动态链接的可执行程序则不一定可以，除非把该exe文件所需的dll文件都一并拷贝过去，或者对方机器上也有所需的相同版本的dll文件，否则不能保证正常运行。

静态链接库是.lib格式的文件，一般在工程的设置界面加入工程中，程序编译时会把lib文件的代码直接链接进目标程序中，因此会增加代码大小，静态链接的可执行文件会大一些，程序运行的时候不再需要其它的库文件，不能手动移除lib代码。

动态链接库是一个包含可由多个程序同时使用的代码和数据的库，它是包含函数和数据的模块，格式.dll。程序运行时动态加载这些模块，运行时可以随意加载和移除，节省内存空间。

动态链接库和静态链接库的相同点是它们都实现了代码的共享，不同点是静态链接库lib文件中的代码被包含exe文件中，该lib中不能再包含其他动态链接或者静态链接的库了。而动态链接库dll可以被调用的exe动态地“引用”和“卸载”，一个dll中可以包含其他动态链接库或者静态链接库。在大型的软件项目中一般要实现很多功能，如果把所有单独的功能写成一个个lib文件的话，程序运行的时候要占用很大的内存空间，导致运行缓慢；但是如果将功能写成dll文件，就可以在用到该功能的时候调用功能对应的dll文件，不用这个功能时将dll文件移除内存，这样可以节省内存空间。



# #include尖括号和双引号的区别？

- #include<> ，从标准库中寻找头文件。

- #include""，从当前目录开始寻找头文件。

# #ifndef,#ifdef,#endif的作用？

防止重复包含头文件。

# 什么是面向对象（OOP）？

面向对象是一种对现实世界理解和抽象的方法、思想，通过将需求要素转化为对象进行问题处理的一种思想。

# 面向对象三剑客


>封装：封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。

**封装的意义在于保护或者防止代码（数据）被我们无意中破坏。**

>继承：继承主要实现重用代码，节省开发时间。子类可以继承父类的一些东西。

>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。

# 公有继承、受保护继承、私有继承

1. 公有继承时，派生类对象可以访问基类中的公有成员，派生类的成员函数可以访问基类中的公有和受保护成员；
2. 私有继承时，基类的成员只能被直接派生类的成员访问，无法再往下继承；
3. 受保护继承时，基类的成员也只被直接派生类的成员访问，无法再往下继承。
4. 公有继承时基类受保护的成员，可以通过派生类对象访问但不能修改。

# 有哪几种情况只能用构造函数初始化列表而不能用赋值初始化？

const成员，引用成员


# 设计模式懂嘛，简单举个例子？

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。

比如单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。

适用于：当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时；当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。

比如工厂模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。

适用于：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定它所创建的对象的时候；当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。





# const

1.const 修饰类的成员变量，表示成员常量，不能被修改。

2.const修饰函数承诺在本函数内部不会修改类内的数据成员，不会调用其它非 const 成员函数。

3.如果 const 构成函数重载，const 对象只能调用 const 函数，非 const 对象优先调用非 const 函数。

4.const 函数只能调用 const 函数。非 const 函数可以调用 const 函数。

5.类体外定义的 const 成员函数，在定义和声明处都需要 const 修饰符。



# 类的static变量在什么时候初始化？函数的static变量在什么时候初始化？

类的静态成员变量在类实例化之前就已经存在了，并且分配了内存。函数的static变量在执行此函数时进行初始化。



# 堆和栈的区别？堆和栈的生命周期？

一、堆栈空间分配区别：

1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；

2、堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。

二、堆栈缓存方式区别：

1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；

2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

三、堆栈数据结构区别：

堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

栈（数据结构）：一种先进后出的数据结构。



# 指针和引用的区别？

1. 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用仅是个别名；

2. 引用使用时无需解引用(*)，指针需要解引用；

3. 引用只能在定义时被初始化一次，之后不可变；指针可变；

4. 引用没有 const，指针有 const；

5. 引用不能为空，指针可以为空；

6. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；

7. 指针和引用的自增(++)运算意义不一样；

8. 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）

9.从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。

# 数组和指针的区别？

1. 数组要么在全局数据区被创建，要么在栈上被创建；指针可以随时指向任意类型的内存块；
2. 修改内容上的差别：
```cpp
char a[] = “hello”;
a[0] = ‘X’;
char *p = “world”; // 注意p 指向常量字符串
p[0] = ‘X’; // 编译器不能发现该错误，运行时错误
```
- 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p所指的内存容量。C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。

# 空指针和悬垂指针的区别？

空指针是指被赋值为NULL的指针；delete指向动态分配对象的指针将会产生悬垂指针。

1. 空指针可以被多次delete，而悬垂指针再次删除时程序会变得非常不稳定；
2. 使用空指针和悬垂指针都是非法的，而且有可能造成程序崩溃，如果指针是空指针，尽管同样是崩溃，但和悬垂指针相比是一种可预料的崩溃。

# 什么是智能指针？

当类中有指针成员时，一般有两种方式来管理指针成员：一是采用值型的方式管理，每个类对象都保留一份指针指向的对象的拷贝；另一种更优雅的方式是使用智能指针，从而实现指针指向的对象的共享。
 
智能指针的一种通用实现技术是使用引用计数。智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。
 
每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。

# 什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？

1. 用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露。

2. 使用的时候要记得指针的长度。

3. malloc的时候得确定在那里free.

4. 对指针赋值的时候应该注意被赋值指针需要不需要释放.

5. 动态分配内存的指针最好不要再次赋值.


# new和malloc的区别？

1. malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。

2. 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。

3. 由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。

4. C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。

5. new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针。

# 描述内存分配方式以及它们的区别

1. 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。

2. 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。

3. 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。


# 解释C++中静态函数和静态变量？


- 类静态数据成员在编译时创建并初始化：在该类的任何对象建立之前就存在，不属于任何对象，而非静态类成员变量则是属于对象所有的。类静态数据成员只有一个拷贝，为所有此类的对象所共享。

- 类静态成员函数属于整个类，不属于某个对象，由该类所有对象共享。

1. static 成员变量实现了同类对象间信息共享。

2. static 成员类外存储，求类大小，并不包含在内。

3. static 成员是命名空间属于类的全局变量，存储在 data 区的rw段。

4. static 成员只能类外初始化。

5. 可以通过类名访问（无对象生成时亦可），也可以通过对象访问。





# const和#define有什么区别？

1. const和#define都可以定义常量，但是const用途更广。
2. const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
3. 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。

# 关于sizeof小结的。

sizeof计算的是在栈中分配的内存大小。
- sizeof不计算static变量占得内存；
- 32位系统的指针的大小是4个字节，64位系统的指针是8字节，而不用管指针类型；
- char型占1个字节，int占4个字节，short int占2个字节,long int占4个字节，float占4字节，double占8字节，string占4字节,一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节
- 数组的长度：若指定了数组长度，则不看元素个数，总字节数=数组长度*sizeof（元素类型）;若没有指定长度，则按实际元素个数类确定
- 结构体对象的长度:在默认情况下，为方便对结构体内元素的访问和管理，当结构体内元素长度小于处理器位数的时候，便以结构体内最长的数据元素的长度为对齐单位，即为其整数倍。若结构体内元素长度大于处理器位数则以处理器位数为单位对齐。
- unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof（unsigned int）=4
- 自定义类型的sizeof取值等于它的类型原型取sizeof
- 对函数使用sizeof，在编译阶段会被函数的返回值的类型代替
- sizeof后如果是类型名则必须加括号，如果是变量名可以不加括号，这是因为sizeof是运算符
- 当使用结构类型或者变量时，sizeof返回实际的大小。当使用静态数组时返回数组的全部大小，sizeof不能返回动态数组或者外部数组的尺寸

# sizeof与strlen的区别？
1. sizeof的返回值类型为size_t（unsigned int）；
2. sizeof是运算符，而strlen是函数；
3. sizeof可以用类型做参数，其参数可以是任意类型的或者是变量、函数，而strlen只能用char*做参数，且必须是以’\0’结尾；
4. 数组作sizeof的参数时不会退化为指针，而传递给strlen是就退化为指针；
5. sizeo是编译时的常量，而strlen要到运行时才会计算出来，且是字符串中字符的个数而不是内存大小；



# C++空类默认有哪些成员函数？

默认构造函数、析构函数、复制构造函数、赋值函数

# 哪一种成员变量可以在一个类的实例之间共享？

static静态成员变量

# 继承层次中，为什么基类析构函数是虚函数？

编译器总是根据类型来调用类成员函数。但是一个派生类的指针可以安全地转化为一个基类的指针。这样删除一个基类的指针的时候，C++不管这个指针指向一个基类对象还是一个派生类的对象，调用的都是基类的析构函数而不是派生类的。如果你依赖于派生类的析构函数的代码来释放资源，而没有重载析构函数，那么会有资源泄漏。

# 为什么构造函数不能为虚函数？

虚函数采用一种虚调用的方法。需调用是一种可以在只有部分信息的情况下工作的机制。如果创建一个对象，则需要知道对象的准确类型，因此构造函数不能为虚函数。

# 如果虚函数是有效的，那为什么不把所有函数设为虚函数？

不行。首先，虚函数是有代价的，由于每个虚函数的对象都要维护一个虚函数表，因此在使用虚函数的时候都会产生一定的系统开销，这是没有必要的。


# 什么是虚指针？

虚指针或虚函数指针是虚函数的实现细节。带有虚函数的每一个对象都有一个虚指针指向该类的虚函数表。

# C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？

1. 将类定义为抽象基类或者将构造函数声明为private；
2. 不允许类外部创建类对象，只能在类内部创建对象


# main函数执行之前会执行什么？执行之后还能执行代码吗？
1. 全局对象的构造函数会在main函数之前执行；
2. 可以，可以用_onexit 注册一个函数，它会在main 之后执行;
如果你需要加入一段在main退出后执行的代码，可以使用atexit()函数，注册一个函数。
语法：
```CPP
#include <stdlib.h>
#include <stdio.h>
int atexit(void (*function")(void));
void fn1( void ), fn2( void ), fn3( void );
int main( void )
{
atexit(fn1);
atexit( fn2 );
printf( "This is executed first.\n" );
}
void fn1()
{
printf( " This is\n" );
}
void fn2()
{
printf( " executed next." );
}
结果：
This is executed first.
This is executed next.
```

# 调用函数时要进行参数压栈，一般情况下顺序是从最右边参数往左压栈。


41.类使用static成员的优点，如何访问？
答：优点：
（1）static 成员的名字是在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突；
（2）可以实施封装。static 成员可以是私有成员，而全局对象不可以；
（3） static 成员是与特定类关联的，可清晰地显示程序员的意图。
static 数据成员必须在类定义体的外部定义(正好一次)，static 关键字只能用于类定义体内部的声明中，定义不能标示为static.
不像普通数据成员，static成员不是通过类构造函数进行初始化，也不能在类的声明中初始化，而是应该在定义时进行初始化.保证对象正好定义一次的最好办法，就是将static
数据成员的定义放在包含类非内联成员函数定义的文件中。
静态数据成员初始化的格式为：
＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞
类的静态数据成员有两种访问形式：
＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞

static数据成员和static成员函数

答：（1）static数据成员：
static数据成员独立于该类的任意对象而存在；每个static数据成员是与类关联的对象，并不与该类的对象相关联。Static数据成员（const
static数据成员除外）必须在类定义体的外部定义。不像普通数据成员，static成员不是通过类的构造函数进行初始化，而是应该在定义时进行初始化。
（2）static成员函数：
Static成员函数没有this形参，它可以直接访问所属类的static成员，不能直接使用非static成员。因为static成员不是任何对象的组成部分，所以static成员不能被声明为const。同时，static成员函数也不能被声明为虚函数。
43.static成员变量定义放在cpp文件中，不能放在初始化列表中。Const static成员可就地初始化。
44.如何引用一个已经定义过的全局变量？
答：可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。
44.static关键字的作用。
答：static总是使得变量或对象的存储形式变成静态存储，连接方式变成内部连接，对于局部变量（已经是内部连接了），它仅改变其存储方式；对于全局变量（已经是静态存储了），它仅改变其连接类型。

# 多态类中的虚函数表是 Compile-Time，还是 Run-Time时建立的?

虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组。而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的，这是实现多态的关键。

一个父类写了一个 virtual 函数，如果子类覆盖它的函数不加 virtual ,也能实现多态?

在子类的空间里，有没有父类的这个函数，或者父类的私有变量? (华为笔试题）
答案：只要基类在定义成员函数时已经声明了 virtue关键字，在派生类实现的时候覆盖该函数时，virtue关键字可加可不加，不影响多态的实现。子类的空间里有父类的所有变量(static除外)。

# 完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？

这些函数的区别在于 实现功能以及操作对象不同。
1. strcpy 函数操作的对象是字符串，完成从源字符串到目的字符串的拷贝功能。
2. sprintf 函数操作的对象不限于字符串：虽然目的对象是字符串，但是源对象可以是字符串、也可以是任意基本类型的数据。这个函数主要用来实现（字符串或基本数据类型）向字符串的转换功能。如果源对象是字符串，并且指定 %s 格式符，也可实现字符串拷贝功能。
3. memcpy
函数顾名思义就是内存拷贝，实现将一个内存块的内容复制到另一个内存块这一功能。内存块由其首地址以及长度确定。程序中出现的实体对象，不论是什么类型，其最终表现就是在内存中占据一席之地（一个内存区间或块）。因此，memcpy的操作对象不局限于某一类数据类型，或者说可适用于任意数据类型，只要能给出对象的起始地址和内存长度信息、并且对象具有可操作性即可。鉴于memcpy函数等长拷贝的特点以及数据类型代表的物理意义，memcpy函数通常限于同种类型数据或对象之间的拷贝，其中当然也包括字符串拷贝以及基本数据类型的拷贝。

对于字符串拷贝来说，用上述三个函数都可以实现，但是其实现的效率和使用的方便程度不同：
- strcpy 无疑是最合适的选择：效率高且调用方便。
- sprintf 要额外指定格式符并且进行格式转化，麻烦且效率不高。
- memcpy 虽然高效，但是需要额外提供拷贝的内存长度这一参数，易错且使用不便；并且如果长度指定过大的话（最优长度是源字符串长度 +1），还会带来性能的下降。

其实 strcpy 函数一般是在内部调用 memcpy 函数或者用汇编直接实现的，以达到高效的目的。因此，使用memcpy 和 strcpy 拷贝字符串在性能上应该没有什么大的差别。对于非字符串类型的数据的复制来说，strcpy 和 snprintf 一般就无能为力了，可是对 memcpy却没有什么影响。但是，对于基本数据类型来说，尽管可以用 memcpy进行拷贝，由于有赋值运算符可以方便且高效地进行同种或兼容类型的数据之间的拷贝，所以这种情况下 memcpy 几乎不被使用 。memcpy的长处是用来实现（通常是内部实现居多）对结构或者数组的拷贝，其目的是或者高效，或者使用方便，甚或两者兼有。

应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？



# C++函数中值的传递方式有哪几种?

三种传递方式为：值传递、指针传递和引用传递。

# C++里面是不是所有的动作都是main()引起的？如果不是，请举例.

比如全局变量的初始化，就不是由main函数引起的
举例：
```CPP
class A{};
A a; //a的构造函数限执行
int main() {}
```


# 内联函数在编译时是否做参数类型检查？

内联函数要做参数类型检查, 这是内联函数跟宏相比的优势。

# 全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？

1. 生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁;局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在； 内存中分配在全局数据区
2. 使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用，分配在栈区
操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。


# static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？

static全局变量与普通全局变量区别：static全局变量只初使化一次，防止在其他文件单元中被引用;

static局部变量和普通局部变量区别：static局部变量只被初始化一次，下一次依据上一次结果值；

static函数与普通函数区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。

程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。

59． 对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?
c用宏定义，c++用inline


# STL库用过吗？常见的STL容器有哪些？算法用过哪几个？


STL包括两部分内容：容器和算法。（重要的还有融合这二者的迭代器）

容器，即存放数据的地方。比如array等。

在STL中，容器分为两类：序列式容器和关联式容器。

序列式容器，其中的元素不一定有序，但都可以被排序。如：vector、list、deque、stack、queue、heap、priority_queue、slist；

关联式容器，内部结构基本上是一颗平衡二叉树。所谓关联，指每个元素都有一个键值和一个实值，元素按照一定的规则存放。如：RB-tree、set、map、multiset、multimap、hashtable、hash_set、hash_map、hash_multiset、hash_multimap。

下面各选取一个作为说明。

vector：它是一个动态分配存储空间的容器。区别于c++中的array，array分配的空间是静态的，分配之后不能被改变，而vector会自动重分配（扩展）空间。

set：其内部元素会根据元素的键值自动被排序。区别于map，它的键值就是实值，而map可以同时拥有不同的键值和实值。

算法，如排序，复制……以及个容器特定的算法。这点不用过多介绍，主要看下面迭代器的内容。

迭代器是STL的精髓，我们这样描述它：迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。它将容器和算法分开，好让这二者独立设计。

# 来源

>[20道必须掌握的C++面试题](w3cschool.cn/cpp/cpp-a9no2ppi.html)
>[60道30K+C++工程师面试必问面试题](https://juejin.im/post/6844903878886948878)