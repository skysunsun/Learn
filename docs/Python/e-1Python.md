

# Python相关

## 聊一下我最擅长的编程语言（Python），Python的特点？  

简单。Python遵循"简单、优雅、明确"的设计哲学。

高级。Python是一种高级语言，相对于c，牺牲了性能而提升了编程人员的效率。它使得程序员可以不用关注底层细节，而把精力全部放在编程上。

Python既支持面向过程，也支持面向对象。

可扩展。可以通过c、c++语言为python编写扩充模块。

免费和开源。Python是FLOSS(自由/开放源码软件)之一，允许自由的发布软件的备份、阅读和修改其源代码、将其一部分自由地用于新的自由软件中。

边编译边执行。Python是解释型语言，边编译边执行。

可移植。Python能运行在不同的平台上。

丰富的库。Python拥有许多功能丰富的库。

可嵌入性。Python可以嵌入到c、c++中，为其提供脚本功能。

## python是怎么做到跨平台的？

Python有不同的编译器，用cPython则把Python编译成Python bytecode然后在不同平台上运行。Python默认的是解释器是cpython。
而Jython则是把Python编译成java bytecode然后再利用java虚拟机来运行。所以可以在这里插入java语言，因为最后都是要编译成java bytecode来运行。

## Python列表的底层是如何实现的

在CPython中，列表被实现为**长度可变的数组**

从细节上看，Python中的列表是由对其它对象的引用组成的连续数组。指向这个数组的指针及其长度被保存在一个列表头结构中。这意味着，每次添加或删除一个元素时，由引用组成的数组需要该标大小（重新分配）。幸运的是，Python在创建这些数组时采用了指数分配，所以并不是每次操作都需要改变数组的大小。但是，也因为这个原因添加或取出元素的平摊复杂度较低。


列表和元组的区别是显然的：
列表是动态的，其大小可以该标 (重新分配)；
而元组是不可变的，一旦创建就不能修改。

list和tuple在c实现上是很相似的，对于元素数量大的时候，
都是一个数组指针，指针指向相应的对象，找不到tuple比list快的理由。
但对于小对象来说，tuple会有一个对象池，所以小的、重复的使用tuple还有益处的。

为什么要有tuple，还有很多的合理性。
实际情况中的确也有不少大小固定的列表结构，例如二维地理坐标等；
另外tuple也给元素天然地赋予了只读属性。


## Python深拷贝浅拷贝

直接赋值：其实就是对象的引用（别名）。

浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。

深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象

## Python中`==`和`is`的区别

`==`是判断对象是否相等，是对两个对象的 value 进行比较，比较两个对象的值是否相等

`is`是判断对象是否相同，是对两个对象的 id 进行比较，比较两个对象的内存地址是否相等

## Python如何实现内存管理？有没有可能出现内存泄露的问题？

Python GC主要使用**引用计数**来跟踪和回收垃圾。在引用计数的基础上，通过**标记-清除**解决容器对象可能产生的循环引用问题。通过分代以空间换时间的方法提高垃圾回收效率

>引用计数：每个对象中都有ob-refcnt来做引用计数。当一个对象...,ob-refcnt就会增加，当引用的对象删除，那么ob-refcnt就会减少当ob-refcnt为零，就会释放该对象的内存空间

>标记清除：解决循环引用的问题。先按需分配，等到没有空闲内存的时候，从寄存器和程序栈上的引用出发，遍历所有对象和引用把所有能访问的打标记，最后将没有标记的对象释放掉

>分代技术：提高效率，提高垃圾回收的效率，按照存活时间，分成不同的集合。将内存块按照其存活时间划分为不同的集合。每个集合就称为一个“代”，垃圾回收的频率随代的存活时间增大而减小。Python默认定义分代对象集合，引用数越大，对象的存活时间越长

Python也会内存泄露，Python本身的垃圾回收机制无法回收重写了del的循环引用的对象.

程序员管理好每个python对象的引用，尽量在不需要使用对象的时候，断开所有引用,尽量少通过循环引用组织数据，可以改用weakref做弱引用或者用id之类的句柄访问对象,通过gc模块的接口可以检查出每次垃圾回收有哪些对象不能自动处理，再逐个逐个处理

## python中`+`和`join`的区别

在用"+"连接字符串时，结果会生成新的对象，用join时结果只是将原列表中的元素拼接起来，所以join效率比较高

## \*arg, \*\*kargs的用法

`*args`是可变位置参数，是一个元组，传入的参数会被放进元组里。

`**kwargs`是可变关键字参数，是一个字典，传入的参数以键值对的形式存放到字典里。

## Python中基本类型有哪些

int 整型 bool 布尔 strintg 字符串 list 列表 tuple 元组dict

## 内置数据结构有哪些?,tuple与list有什么区别?

(tuple, list, dict, set)

**同**
1. 都是序列
2. 都可以存储任何数据类型
3. 可以通过索引访问

**不同**
元组是不可变的(导致元组无法复制)， 而列表是可变的(导致不能将列表用作字典中的key)

## 装饰器

装饰器本上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下加额外功能，装饰器的回亻自也是一个函数对象·它经常用于有切面需求的场景，比如：庙入a志性能测试、生务处理、存、权限校验等场景·装饰器果解决司题的绝佳设计，有了装饰器，我们就可以掖出大量与函数功能本身无关的雷同代码荇继续重用。概的讲，装饰器的作用就是为已经存在的对隙添昶额外的功能·

## 迭代器，生成器

迭代器：迭代就是循环。迭代器是可以被next() 函数调用并不断返回下一个值的对象称为迭代器。

生成器是通过一个或多个yield表达式构成的函数，每个一个生成器都是一个继承器（但是迭代器不一定是生成器）。

如果一个函数包含yield关键字，这个函数就会变成一个生成器。

生成器并不会一次返回所有结果，或者每次遇到yield关键字后返回相应结果，并保留函数当前的运行状态，等待下一次的调用。

由于生成器也是一个迭代器，那么它就应该支持next方法来获取下一个值。


## range和xrange区别，xrange通过什么关键字实现的？

range直接生成一个可迭代的list，xrange 生成器，省内存

xrange通过yield实现


## yield语句底层如何实现？

所以生成器对象每次执行结束都把字节码的偏移量记录下来，并把运行状态保存在PyFrameObject里，下一次运行时生成器时，python解释器直接按照偏移量寻找下一个字节码指令。

## 有了解过分布式和集群吗？分布式和集群的区别？

分布式是指通过网络连接的多个组件，通过交换信息协作而形成的系统。而集群，是指同一种组件的多个实例，形成的逻辑上的整体。

## Python的异常处理？

捕捉异常可以使用try/except语句。

try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。

如果你不想在异常发生时结束你的程序，只需在try里捕获它

try的工作原理是，当开始一个try语句后，Python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。

1. 如果当try后的语句执行时发生异常，Python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。
2. 如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印默认的出错信息）。
3. 如果在try子句执行时没有发生异常，Python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。

使用raise语句自己触发异常

用户自定义异常


## 什么是进程(process)和线程(thread)

进程是操作系统分配资源的最小单元, 线程是操作系统调度的最小单元。

一个应用程序至少包括1个进程，而1个进程包括1个或多个线程，线程的尺度更小。

每个进程在执行过程中拥有独立的内存单元，而一个线程的多个线程在执行过程中共享内存。

### 讲一下多线程与多进程区别



|维度|多进程|多线程|总结|
| :----: | :----: | :----: | :----: |
|数据共享、同步|数据是分开的:共享复杂，需要用IPC; 同步简单|多线程共享进程数据：共享简单；同步复杂|各有优势|
|内存、CPU|占用内存多，切换复杂，CPU利用率低|占用内存少，切换简单，CPU利用率高|线程占优|
|创建销毁、切换|创建销毁、切换复杂，速度慢 |创建销毁、切换简单，速度快 |线程占优| 
|编程调试|编程简单，调试简单|编程复杂，调试复杂|进程占优 |
|可靠性|进程间不会相互影响 |一个线程挂掉将导致整个进程挂掉|进程占优|
|分布式 |适应于多核、多机分布 ；如果一台机器不够，扩展到多台机器比较简单|适应于多核分布|进程占优|


### 线程池

在使用多线程处理任务时也不是线程越多越好。因为在切换线程的时候，需要切换上下文环境，线程很多的时候，依然会造成CPU的大量开销。为解决这个问题，线程池的概念被提出来了。

预先创建好一个数量较为优化的线程组，在需要的时候立刻能够使用，就形成了线程池。在Python中，没有内置的较好的线程池模块，需要自己实现或使用第三方模块。


### 进程间的通信有哪些？能详细的讲出一两个来吗？

ipc，常用的有socke，rpc，pipe和消息队列等。

应优先考虑Pipe和Queue，避免使用Lock/Event/Semaphore/Condition等同步方式 (因为它们占据的不是用户进程的资源)。

pipe只能适用于两个进程间通信，queue则没这个限制


全局变量(一个读，一个写这种)

消息队列--queue模块

queue模块实现了多生产者，多消费者的队列。当 要求信息必须在多线程间安全交换，这个模块在线程编程时非常有用 。

## 之前用过哪些设计模式？

## TCP为什么是三次握手？

1. 第一次握手： 客户端向服务器发出连接请求报文，这时报文首部中的同部位SYN=1，同时随机生成初始序列号 seq=x，此时，客户端进程进入了 SYN-SENT状态，等待服务器的确认。
2. 第二次握手： 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己随机初始化一个序列号 seq=y，此时，服务器进程进入了SYN-RCVD状态，询问客户端是否做好准备。
3. 第三次握手：  客户端进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，此时，连接建立，客户端进入ESTABLISHED状态，服务器端也进入ESTABLISHED状态。

### TCP握手为什么是三次
握手为什么需要三次呢，如果把最后一次的去掉改为两次握手是否可行呢?
假如现在客户端想向服务端进行握手，它发送了第一个连接的请求报文，但是由于网络信号差或者服务器负载过多，这个请求没有立即到达服务端，而是在某个网络节点中长时间的滞留了，以至于滞留到客户端连接释放以后的某个时间点才到达服务端，那么这就是一个失效的报文，但是服务端接收到这个失效的请求报文后，就误认为客户端又发了一次连接请求，服务端就会想向客户端发出确认的报文，表示同意建立连接。
假如不采用三次握手，那么只要服务端发出确认，表示新的建立就连接了。但是现在客户端并没有发出建立连接的请求，其实这个请求是失效的请求，一切都是服务端在自相情愿，因此客户端是不会理睬服务端的确认信息，也不会向服务端发送确认的请求，但是服务器却认为新的连接已经建立起来了，并一直等待客户端发来数据，这样的情况下，服务端的很多资源就没白白浪费掉了。
采用三次握手的办法就是为了防止上述这种情况的发生，比如就在刚才的情况下，客户端不会向服务端发出确认的请求，服务端会因为收不到确认的报文，就知道客户端并没有要建立连接，那么服务端也就不会去建立连接，这就是三次握手的作用。

## TCP四次挥手

1. 第一次挥手：  客户端进程发出连接释放FIN报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=x,此时，客户端进入FIN-WAIT-1（终止等待1）状态。
2. 第二次挥手：  服务端进程收到连接释放FIN报文，发出确认ACK报文，ACK=1，ack=x+1，并且带上自己的序列号seq=y，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。此时，服务端通知高层的应用进程，客户端向服务端的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务端若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。客户端收到服务端的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文，在这之前依然可以接收服务端发送过来的最后的数据。
3. 第三次挥手： 服务端将最后的数据发送给客户端完成后，就向客户端发送连接释放FIN报文，FIN=1，ack=x+1，此时的序列号为seq=z，此时，服务端就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
4. 第四次挥手： 客户端接收到服务端的连接释放FIN报文后，必须发出确认报文，ACK=1，ack=z+1，而自己的序列号是seq=x+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。此时服务端收到客户端发送过来的确认报文，就立即撤销自己的传输控制块TCB,进入CLOSED状态，注意此时的TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，客户端没有收到服务端发来的任何数据，证明服务端已正常关闭，此时客户端会撤销相应传输控制块TCB后，进入CLOSED状态。至此，TCP的连接才真正的断开了。（服务端结束TCP连接的时间要比客户端稍微早一些）

### TCP为什么要四次挥手

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工 模式，这就意味着，在客户端想要断开连接时，客户端向服务端发送FIN报文，只是表示客户端已经没有数据要发送了，但是这个时候客户端还是可以接收来自服务端的数据。
当服务端接收到FIN报文，并返回ACK报文，表示服务端已经知道了客户端要断开连接，客户端已经没有数据要发送了，但是这个时候服务端可能依然有数据要传输给客户端。
当服务端的数据传输完之后，服务端会发送FIN报文给客户端，表示服务端也没有数据要传输了，服务端同意关闭连接，之后，客户端收到FIN报文，立即发送给客户端一个ACK报文，确定关闭连接。在之后，客户端和服务端彼此就愉快的断开了这次的TCP连接。
或许会有疑问，为什么服务端的ACK报文和FIN报文都是分开发送的，但是在三次握手的时候却是ACK报文和SYN报文是一起发送的，因为在三次握手的过程中，当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是在关闭连接时，当服务端接收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，你发的FIN报文我收到了，只有等到服务端所有的数据都发送完了，才能发送FIN报文，因此ACK报文和FIN报文不能一起发送。所以断开连接的时候才需要四次挥手来完成。


## TCP和UDP的区别

1. TCP是面向连接的，UDP是无连接的；

2. TCP是可靠的，UDP是不可靠的；

3. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；

4. TCP是面向字节流的，UDP是面向报文的；

5. TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；

6. TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；


## Python中的`__new__`和`__init__`的区别

`__new__`和`__init__`的主要区别在于：`__new__`是用来创造一个类的实例的（constructor），而`__init__`是用来初始化一个实例的（initializer）。

## DNS在网络层用哪个协议，为什么。

## 介绍HTTPS协议，详述SSL建立连接过程。

## 介绍各种网络协议。

## 数据库的隔离级别



