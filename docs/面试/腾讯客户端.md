# 内存对齐

将数据尽量的存储在一个步长内，避免跨步长的存储，这就是内存对齐

# 单核CPU如何执行多线程

1.(单核CPU)同一时间,cpu只能处理1个线程,只有1个线程在执行

2.多线程同时执行:是CPU快速的在多个线程之间的切换

3.cpu调度线程的时间足够快,就造成了多线程的“同时”执行

4.如果线程数非常多,cpu会在n个线程之间切换,消耗大量的cpu资源

5.每个线程被调度的次数会降低,线程的执行效率降低

# 逻辑地址到物理地址的具体转换过程

例如：
已知某个分页系统，页面大小为1K(即1024字节)，某一个作业有4个页面，分别装入到主存的第3、4、6、8块中，求逻辑地址2100对应的物理地址。

解：
第一步：求该逻辑地址的页号 = 2100/1024=2 （整除）
第二步：求它的页内偏移量 = 2100 % 1024 =52 （取余）
第三步：根据题目产生页表：
页号    页框号/帧号
   0           3
   1           4
   2           6 
   3           8
第四步：根据逻辑地址的页号查出物理地址的页框号/帧号： 
如上图，逻辑地址的第2页对应物理地址的第6块。
第五步：求出物理地址 = 6*1024 + 52 = 6196

# 四次挥手后，客户端不想等了，怎么写命令退出？

signal？

kill?

# 服务端收不到信息咋办，重发计时器的时间是多少？

很明显我们不会让上面的情况发生。在第一次重传还是没有收到主机B的确认应答以后，主机A就会将这个重传定时器的时间设置的长一点（一般都是2倍增长）。在Linux中，超时重传以500ms为单位进行控制，比如说第一次设置500ms，第二次设置1000ms，第三次就设置2000ms。当然不可能无限地一直往上增长，在累计一定的重传次数后，主机A就会认为网络或者对端主机出现异常，强制关闭连接。

# redis缓存和数据库一致性，redis容灾，redis集群，主从复制详细介绍一下

快照aof


# 如何保证事务的一致性？能具体说说原理吗？

快照 aof 主从复制

# MySql与Redis在哪些方面不同？

关系型非关系型数据库

# 就关系数据库和非关系数据库的区别讲了

关系型：

    1. 复杂查询
    可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
    2. 事务支持
    使得对于安全性能很高的数据访问要求得以实现。

非关系型

    1. 性能
    NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
    2. 可扩展性
    同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

# 还想提一提Redis的内存管理和持久化的

定期删除/惰性删除

淘汰策略

快照和AOF

# 数据库，怎么回滚，怎么优化查询。

主从复制
aof

优化索引

优化表结构

# 表模型
多个excel表


# 你认为什么时候建立索引？

1、较频繁地作为查询条件的字段
2、唯一性太差的字段不适合建立索引
3、更新太频繁地字段不适合创建索引
4、不会出现在where条件中的字段不该建立索引



# 索引会在什么时候失效？

1.如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)

2.对于多列索引，不是使用的第一部分(第一个)，则不会使用索引
3.like查询是以%开头
4.如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
5.如果mysql估计使用全表扫描要比使用索引快,则不使用索引

1) 没有查询条件，或者查询条件没有建立索引 
2) 在查询条件上没有使用引导列 
3) 查询的数量是大表的大部分，应该是30％以上。 
4) 索引本身失效


# 假设Redis的一个key对应的list数据非常多？你会怎么解决？

拆分


# 读写分离会有哪些问题？

由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态

Q：除了之前说的三种方式，还有吗？

# linux命令你知道哪些？
ps
cat
cp
mv
top
uptime
w
netstat
kill
less
more
find
free


# 由一个url下载一个东西的过程是怎样的

和请求是一样的吧

dns解析
tcp握手建立连接
http请求
htpp传输数据

# 面向对象和面向过程的区别，都是什么意思，怎么体现的

面向过程：基于算法

　　优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
　　缺点：没有面向对象易维护、易复用、易扩展

面向对象：基于数据

　　优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
　　缺点：性能比面向过程低


# 状态码

100 继续
200 ok
301 重定向：迁到新地址了
400 语法错误
403 权限不够
404 找不到
500 服务器错误


# topk问题

# 递归和迭代有什么区别

# 快排

# 数组合并

# 接雨水那道，我先用单调栈解出来了。

# 子序列

# 股票

# 抓出数组中第三大的数 要求时间复杂度o（n）

# 问你怎么判断两个链表有没有相交

# 翻转链表

# 最短路径的算法

Dijkstra

    1、定义，遍历过的节点集合为S，集合U为其余节点（即未遍历）。初始时，S只包含源点v，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}。若v与U中顶点u有边，则正常有权值，若u不是v的出边邻接点，则权值为∞。

    注：这里集合S、U，是为了判断哪些节点已经遍历过，如果U为空了，就不继续执行。

    2、从集合U中选取一个距离v最小的顶点k，把k加入到S中。

    3、以k为新考虑的中间点，修改v到U中各顶点的距离；若从源点v到顶点w的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改v到w的距离值。

Floyd算法

    1. 从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 　　

    2. 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。



# 避免`if`,`else`过多

使用函数字典

# 大数问题

# 红黑树

根结点为黑色

根结点到叶子节点不能有连续的红色节点

叶子节点全部是黑色的空节点


